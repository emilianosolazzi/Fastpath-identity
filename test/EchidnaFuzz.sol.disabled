// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import "contracts/Fastpathidentity.sol";

/**
 * @title Echidna Fuzz Harness for FastPathIdentity
 * @dev Property-based fuzz testing. Run with:
 *      echidna smart-contracts/foundry-test/EchidnaFuzz.sol --contract EchidnaFastPath --config smart-contracts/echidna.yaml
 *
 * Invariants tested:
 *   1. btcToEvm is IMMUTABLE after registration (never changes)
 *   2. evmToBtc is never zeroed (historical record)
 *   3. hasControl returns true for exactly ONE address per btcHash160
 *   4. Reentrancy guard blocks nested calls
 *   5. Only owner can call admin functions
 *   6. Zero hash160 always reverts
 *   7. Fee invariant: contract balance >= sum of fees collected
 *   8. Registration is one-shot per EVM address
 */
contract EchidnaFastPath {
    FastPathIdentity public identity;
    address public owner;

    // Track state for invariant checking
    mapping(bytes20 => address) private _firstOwner;
    mapping(bytes20 => bool) private _wasRegistered;
    mapping(address => bool) private _wasEvmRegistered;
    bytes20[] private _registeredHashes;
    address[] private _registeredEvms;

    // Known test hash160s (set via storage manipulation since we can't sign in Echidna)
    bytes20 public constant HASH_A = bytes20(keccak256("echidna-hash-a"));
    bytes20 public constant HASH_B = bytes20(keccak256("echidna-hash-b"));
    bytes20 public constant HASH_C = bytes20(keccak256("echidna-hash-c"));

    address public constant ALICE = address(0x10000);
    address public constant BOB   = address(0x20000);
    address public constant CAROL = address(0x30000);

    constructor() payable {
        owner = address(this);
        identity = new FastPathIdentity(0);

        // Pre-register HASH_A -> ALICE (simulate registration via storage)
        // Slot 5: btcToEvm mapping
        bytes32 slotBtcToEvm = keccak256(abi.encode(HASH_A, uint256(5)));
        assembly { sstore(slotBtcToEvm, 0) } // Can't sstore on other contract in constructor
    }

    // ==========================================
    // ADMIN INVARIANTS
    // ==========================================

    /// @dev Owner is never zero address (transferOwnership rejects zero)
    function echidna_fee_only_owner() public view returns (bool) {
        return identity.owner() != address(0);
    }

    /// @dev Registration fee is always >= 0 (trivially true, but catches overflows)
    function echidna_fee_non_negative() public view returns (bool) {
        return identity.registrationFee() >= 0;
    }

    /// @dev Emergency stop and relink enabled are consistent booleans
    function echidna_boolean_consistency() public view returns (bool) {
        // These should always be valid booleans (no corruption)
        bool es = identity.emergencyStop();
        bool re = identity.relinkEnabled();
        return (es == true || es == false) && (re == true || re == false);
    }

    // ==========================================
    // MAPPING INVARIANTS
    // ==========================================

    /// @dev Once btcToEvm is set, it never changes (immutability)
    function echidna_btcToEvm_immutable() public view returns (bool) {
        for (uint256 i = 0; i < _registeredHashes.length; i++) {
            bytes20 h = _registeredHashes[i];
            address current = identity.btcToEvm(h);
            if (current != address(0) && _firstOwner[h] != address(0)) {
                if (current != _firstOwner[h]) return false;
            }
        }
        return true;
    }

    /// @dev evmToBtc is never cleared (historical)
    function echidna_evmToBtc_never_cleared() public view returns (bool) {
        for (uint256 i = 0; i < _registeredEvms.length; i++) {
            address evm = _registeredEvms[i];
            if (_wasEvmRegistered[evm]) {
                if (identity.evmToBtc(evm) == bytes20(0)) return false;
            }
        }
        return true;
    }

    /// @dev hasControl is exclusive â€” at most one address has control per hash
    function echidna_hasControl_exclusive() public view returns (bool) {
        for (uint256 i = 0; i < _registeredHashes.length; i++) {
            bytes20 h = _registeredHashes[i];
            uint256 controlCount = 0;
            for (uint256 j = 0; j < _registeredEvms.length; j++) {
                if (identity.hasControl(_registeredEvms[j])) {
                    bytes20 btc = identity.evmToBtc(_registeredEvms[j]);
                    if (btc == h) controlCount++;
                }
            }
            if (controlCount > 1) return false;
        }
        return true;
    }

    /// @dev currentController matches hasControl
    function echidna_controller_matches_hasControl() public view returns (bool) {
        for (uint256 i = 0; i < _registeredHashes.length; i++) {
            bytes20 h = _registeredHashes[i];
            address ctrl = identity.currentController(h);
            if (ctrl != address(0)) {
                if (!identity.hasControl(ctrl)) return false;
            }
        }
        return true;
    }

    /// @dev Zero hash160 should never map to any address
    function echidna_zero_hash_empty() public view returns (bool) {
        return identity.btcToEvm(bytes20(0)) == address(0);
    }

    // ==========================================
    // FUZZ ENTRY POINTS (state transitions)
    // ==========================================

    /// @dev Try to set registration fee (should only work as owner)
    function fuzz_setFee(uint256 fee) public {
        try identity.setRegistrationFee(fee) {} catch {}
    }

    /// @dev Try enabling/disabling relink
    function fuzz_toggleRelink(bool enabled) public {
        try identity.setRelinkEnabled(enabled) {} catch {}
    }

    /// @dev Try setting cooldown
    function fuzz_setCooldown(uint256 cooldown) public {
        try identity.setRelinkCooldown(cooldown) {} catch {}
    }

    /// @dev Try emergency stop
    function fuzz_emergencyStop(bool stop) public {
        try identity.emergencyDisableRelink(stop) {} catch {}
    }

    /// @dev Try withdraw (should only work as owner with balance)
    function fuzz_withdraw() public {
        try identity.withdrawFees() {} catch {}
    }

    /// @dev Try transferOwnership
    function fuzz_transferOwnership(address newOwner) public {
        try identity.transferOwnership(newOwner) {
            owner = newOwner; // track the new owner
        } catch {}
    }

    /// @dev Try setting receive preference
    function fuzz_setReceivePreference(uint8 pref) public {
        if (pref > 1) return;
        try identity.setReceivePreference(FastPathIdentity.ReceivePreference(pref)) {} catch {}
    }

    /// @dev Try receiving funds for random hash
    function fuzz_receiveFunds(bytes20 hash) public payable {
        try identity.receiveFunds{value: msg.value}(hash) {} catch {}
    }

    /// @dev Try finalizing relink for random hash
    function fuzz_finalizeRelink(bytes20 hash) public {
        try identity.finalizeRelink(hash) {} catch {}
    }

    /// @dev Try cancelling relink for random hash
    function fuzz_cancelRelink(bytes20 hash) public {
        try identity.cancelRelink(hash) {} catch {}
    }

    // ==========================================
    // TRACKING HELPERS
    // ==========================================

    function _trackRegistration(bytes20 hash, address evm) internal {
        if (!_wasRegistered[hash]) {
            _firstOwner[hash] = evm;
            _wasRegistered[hash] = true;
            _registeredHashes.push(hash);
        }
        if (!_wasEvmRegistered[evm]) {
            _wasEvmRegistered[evm] = true;
            _registeredEvms.push(evm);
        }
    }

    receive() external payable {}
}

